//! # Shader Program Creation
//! <https://www.khronos.org/opengl/wiki/Category:Core_API_Ref_Shader_Program_Creation>
//!
//! # Description
//! The core OpenGL API reference for functions that create
//! [GLSL](https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language)
//! [shader and program objects](https://www.khronos.org/opengl/wiki/GLSL_Object), as well as
//! [Program Pipeline Objects](https://www.khronos.org/opengl/wiki/Shader_Compilation#Program_pipelines).
//! These functions either directly create shader objects or affect how shaders and programs are
//! compiled or linked together.

use crate::prelude::*;
use gl::types::*;

#[derive(Default, Debug, Copy, Clone, PartialEq)]
#[repr(transparent)]
pub struct Program(pub u32);

#[derive(Default, Debug, Copy, Clone, PartialEq)]
#[repr(transparent)]
pub struct Shader(pub u32);

/// # indicates the type of shader
#[derive(Debug, Copy, Clone, PartialEq)]
pub enum ShaderType {
    /// shader that is intended to run on the programmable compute processor
    Compute,

    /// shader that is intended to run on the programmable vertex processor
    Vertex,

    /// shader that is intended to run on the programmable tessellation processor in the control stage
    TessControl,

    /// shader that is intended to run on the programmable tessellation processor in the evaluation stage
    TessEvaluation,

    /// shader that is intended to run on the programmable geometry processor
    Geometry,

    /// shader that is intended to run on the programmable fragment processor
    Fragment,
}

impl From<ShaderType> for u32 {
    fn from(value: ShaderType) -> Self {
        match value {
            ShaderType::Compute => gl::COMPUTE_SHADER,
            ShaderType::Vertex => gl::VERTEX_SHADER,
            ShaderType::TessControl => gl::TESS_CONTROL_SHADER,
            ShaderType::TessEvaluation => gl::TESS_EVALUATION_SHADER,
            ShaderType::Geometry => gl::GEOMETRY_SHADER,
            ShaderType::Fragment => gl::FRAGMENT_SHADER,
        }
    }
}

/// # Attaches a shader object to a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glAttachShader.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to which a shader object will be attached.
/// * `shader` - Specifies the shader object that is to be attached.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// attach_shader(Program(42), Shader(7));
/// ```
///
/// # Description
/// In order to create a complete shader program, there must be a way to specify the list of things
/// that will be linked together. Program objects provide this mechanism. Shaders that are to be
/// linked together in a program object must first be attached to that program object.
/// [attach_shader] attaches the shader object specified by `shader` to the program object specified
/// by `program`. This indicates that `shader` will be included in link operations that will be
/// performed on `program`.
///
/// All operations that can be performed on a shader object are valid whether or not the shader
/// object is attached to a program object. It is permissible to attach a shader object to a program
/// object before source code has been loaded into the shader object or before the shader object has
/// been compiled. It is permissible to attach multiple shader objects of the same type because
/// each may contain a portion of the complete shader. It is also permissible to attach a shader
/// object to more than one program object. If a shader object is deleted while it is attached to a
/// program object, it will be flagged for deletion, and deletion will not occur until
/// [detach_shader] is called to detach it from all program objects to which it is attached.
///
/// # Errors
/// * [Error::InvalidValue] - if either `program` or `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` is not a program object
/// * [Error::InvalidOperation] - if `shader` is not a shader object
/// * [Error::InvalidOperation] - if `shader` is already attached to `program`
///
/// # Associated Gets
/// * [get_attached_shaders]
/// * [get_shader_info_log]
/// * [get_shader_source]
/// * [is_program]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [attach_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
/// * [detach_shader]
/// * [link_program]
/// * [shader_source]
pub fn attach_shader(program: Program, shader: Shader) {
    let program = program.0;
    let shader = shader.0;

    // SAFE: synchronous integer copy
    unsafe { gl::AttachShader(program, shader) }
}

/// # Compiles a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCompileShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be compiled.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// compile_shader(Shader(42))
/// ```
///
/// # Description
/// [compile_shader] compiles the source code strings that have been stored in the shader object
/// specified by `shader`.
///
/// The compilation status will be stored as part of the shader object's state. This value will be
/// set to true if the shader was compiled without errors and is ready for use, and false otherwise.
/// It can be queried by calling [get_shader_compile_status].
///
/// Compilation of a shader can fail for a number of reasons as specified by the OpenGL Shading
/// Language Specification. Whether or not the compilation was successful, information about the
/// compilation can be obtained from the shader object's information log by calling
/// [get_shader_info_log].
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` is not a shader object.
///
/// # Associated Gets
/// * [get_shader_info_log]
/// * [get_shader_compile_status]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [compile_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [create_shader]
/// * [link_program]
/// * [shader_source]
pub fn compile_shader(shader: Shader) {
    let shader = shader.0;

    // SAFE: synchronous integer copy
    unsafe { gl::CompileShader(shader) }
}

/// # Creates a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateProgram.xhtml>
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// let program: Program = create_program();
/// assert_ne!(program, Program(0));
/// ```
///
/// # Description
/// [create_program] creates an empty program object and returns a non-zero value by which it can be
/// referenced. A program object is an object to which shader objects can be attached. This provides
/// a mechanism to specify the shader objects that will be linked to create a program. It also
/// provides a means for checking the compatibility of the shaders that will be used to create a
/// program (for instance, checking the compatibility between a vertex shader and a fragment
/// shader). When no longer needed as part of a program object, shader objects can be detached.
///
/// One or more executables are created in a program object by successfully attaching shader objects
/// to it with [attach_shader], successfully compiling the shader objects with [compile_shader], and
/// successfully linking the program object with [link_program]. These executables are made part of
/// current state when [use_program] is called. Program objects can be deleted by calling
/// [delete_program]. The memory associated with the program object will be deleted when it is no
/// longer part of current rendering state for any context.
///
/// Like buffer and texture objects, the name space for program objects may be shared across a set
/// of contexts, as long as the server sides of the contexts share the same address space. If the
/// name space is shared across contexts, any attached objects and the data associated with those
/// attached objects are shared as well.
///
/// Applications are responsible for providing the synchronization across API calls when objects are
/// accessed from different execution threads.
///
/// # Errors
/// * This function returns Program(0) if an error occurs creating the program object.
///
/// # Associated Gets
/// * [get_current_program]
/// * [get_active_attrib] with a valid program object and the index of an active attribute variable
/// * [get_active_uniform] with a valid program object and the index of an active uniform variable
/// * [get_attached_shaders] with a valid program object
/// * [get_attrib_location] with a valid program object and the name of an attribute variable
/// *  all `get_program_*` variants
/// * [get_program_info_log] with a valid program object
/// * [get_uniform] with a valid program object and the location of a uniform variable
/// * [get_uniform_location] with a valid program object and the name of a uniform variable
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [create_program] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [bind_attrib_location]
/// * [create_shader]
/// * [delete_program]
/// * [detach_shader]
/// * [link_program]
/// * all `uniform_*` variants
/// * [use_program]
/// * [validate_program]
pub fn create_program() -> Program {
    // SAFE: synchronous integer copy
    let val = unsafe { gl::CreateProgram() };
    Program(val)
}

/// # Creates a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glCreateShader.xhtml>
///
/// # Arguments
/// * `shader_type` - Specifies the type of shader to be created
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// let shader: Shader = create_shader(ShaderType::Vertex);
/// assert_ne!(shader, Shader(0));
/// ```
///
/// # Description
/// [create_shader] creates an empty shader object and returns a non-zero value by which it can be
/// referenced. A shader object is used to maintain the source code strings that define a shader.
///
/// Like buffer and texture objects, the name space for shader objects may be shared across a set of
/// contexts, as long as the server sides of the contexts share the same address space. If the name
/// space is shared across contexts, any attached objects and the data associated with those
/// attached objects are shared as well.
///
/// Applications are responsible for providing the synchronization across API calls when objects are
/// accessed from different execution threads.
///
/// # Compatability
/// * 4.3 - [ShaderType::Compute]
///
/// # Errors
/// * This function returns 0 if an error occurs creating the shader object.
///
/// # Associated Gets
/// * all `get_shader_*` variants
/// * [get_shader_info_log]
/// * [get_shader_source]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [create_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [compile_shader]
/// * [delete_shader]
/// * [detach_shader]
/// * [shader_source]
pub fn create_shader(shader_type: ShaderType) -> Shader {
    let shader_type = GLenum::from(shader_type);

    // SAFE: synchronous integer copy
    let val = unsafe { gl::CreateShader(shader_type) };
    Shader(val)
}

/// # Deletes a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be deleted.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// delete_program(Program(42));
/// ```
///
/// # Description
/// [delete_program] frees the memory and invalidates the name associated with the program object
/// specified by `program`. This command effectively undoes the effects of a call to
/// [create_program].
///
/// If a program object is in use as part of current rendering state, it will be flagged for
/// deletion, but it will not be deleted until it is no longer part of current state for any
/// rendering context. If a program object to be deleted has shader objects attached to it, those
/// shader objects will be automatically detached but not deleted unless they have already been
/// flagged for deletion by a previous call to glDeleteShader. A value of 0 for `program` will be
/// silently ignored.
///
/// To determine whether a program object has been flagged for deletion, call
/// [get_program_delete_status]
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
///
/// # Associated Gets
/// * [get_current_program]
/// * [get_program_delete_status]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [delete_program] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [create_shader]
/// * [detach_shader]
/// * [use_program]
pub fn delete_program(program: Program) {
    let program = program.0;

    // SAFE: synchronous integer copy
    unsafe { gl::DeleteProgram(program) }
}

/// # Deletes a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDeleteShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be deleted.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// delete_shader(Shader(42));
/// ```
///
/// # Description
/// [delete_shader] frees the memory and invalidates the name associated with the shader object
/// specified by `shader`. This command effectively undoes the effects of a call to [create_shader].
///
/// If a shader object to be deleted is attached to a program object, it will be flagged for
/// deletion, but it will not be deleted until it is no longer attached to any program object, for
/// any rendering context (i.e., it must be detached from wherever it was attached before it will be
/// deleted). A value of 0 for `shader` will be silently ignored.
///
/// To determine whether an object has been flagged for deletion, call [get_shader_delete_status].
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
///
/// # Associated Gets
/// * [get_attached_shaders] with the program object to be queried
/// * [get_shader_delete_status]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [delete_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [create_program]
/// * [create_shader]
/// * [detach_shader]
/// * [use_program]
pub fn delete_shader(shader: Shader) {
    let shader = shader.0;

    // SAFE: synchronous integer copy
    unsafe { gl::DeleteShader(shader) }
}

/// # Detaches a shader object from a program object to which it is attached
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDetachShader.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object from which to detach the shader object.
/// * `shader` - Specifies the shader object to be detached.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// detach_shader(Program(42), Shader(7));
/// ```
///
/// # Description
/// [detach_shader] detaches the shader object specified by `shader` from the program object
/// specified by `program`. This command can be used to undo the effect of the command
/// [attach_shader].
///
/// If `shader` has already been flagged for deletion by a call to [delete_shader] and it is not
/// attached to any other program object, it will be deleted after it has been detached.
///
/// # Errors
/// * [Error::InvalidValue] - if either `program` or `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` is not a program object
/// * [Error::InvalidOperation] - if `shader` is not a shader object
/// * [Error::InvalidOperation] - if `shader` is already attached to `program`
///
/// # Associated Gets
/// * [get_attached_shaders] with the handle of a valid program object
/// * [get_shader_delete_status]
/// * [is_program]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [detach_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
pub fn detach_shader(program: Program, shader: Shader) {
    let program = program.0;
    let shader = shader.0;

    // SAFE: synchronous integer copy
    unsafe { gl::DetachShader(program, shader) }
}

/// # Returns the handles of the shader objects attached to a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetAttachedShaders.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
/// * `buffer` - Specifies a mut slice that is used to return the names of attached shader objects.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// let mut buffer = [Default::default(); 5];
/// let shaders: &[Shader] = get_attached_shaders(Program(42), &mut buffer);
/// ```
///
/// Using pre-allocation
/// ```no_run
/// # use rgl::prelude::*;
/// let program = Program(42);
///
/// let mut buffer = Vec::new();
/// buffer.resize(get_program_attached_shaders(program) as usize, Default::default());
/// let shaders: &[Shader] = get_attached_shaders(program, &mut buffer);
/// ```
///
/// # Description
/// [get_attached_shaders] returns the names of the shader objects attached to `program`. The names
/// of shader objects that are attached to `program` will be returned. If no shader objects are
/// attached to `program`, it return `&[]`. The maximum number of shader names that may be returned
/// in shaders is specified by the buffer `buffer` input size. To acquire the full buffer size
/// beforehand, use `get_program_attached_shaders_count`.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` is not a program object.
///
/// # Associated Gets
/// * [get_program_attached_shaders]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [program] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [detach_shader]
pub fn get_attached_shaders(program: Program, buffer: &mut [Shader]) -> &[Shader] {
    let program = program.0;
    let max_count = buffer.len() as GLsizei;
    let mut count: GLsizei = Default::default();
    let count_out = &mut count as *mut GLsizei;
    let shaders_out = buffer.as_mut_ptr() as *mut u32;

    // SAFE: synchronous write to out params, no memory retained
    unsafe { gl::GetAttachedShaders(program, max_count, count_out, shaders_out) };

    let count = count as usize;
    &buffer[..count]
}

fn get_program_iv(program: Program, pname: GLenum) -> i32 {
    let program = program.0;
    let mut params = Default::default();
    let params_out = &mut params as *mut GLint;

    // SAFE: synchronous write to `params_out`, no memory retained
    unsafe { gl::GetProgramiv(program, pname, params_out) };
    params
}

/// # Returns program delete status
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(get_program_delete_status(Program(42)));
/// ```
///
/// # Description
/// Returns true if `program` is currently flagged for deletion, and false otherwise.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_delete_status] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_delete_status(program: Program) -> bool {
    let val = get_program_iv(program, gl::DELETE_STATUS);
    val == gl::TRUE as i32
}

/// # Returns program link status
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(get_program_link_status(Program(42)));
/// ```
///
/// # Description
/// Returns true if the last link operation on `program` was successful, and false otherwise.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_link_status] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_link_status(program: Program) -> bool {
    let val = get_program_iv(program, gl::LINK_STATUS);
    val == gl::TRUE as i32
}

/// # Returns program validation status
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(get_program_validate_status(Program(42)));
/// ```
///
/// # Description
/// Returns true or if the last validation operation on `program` was successful, and false
/// otherwise.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_validate_status] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_validate_status(program: Program) -> bool {
    let val = get_program_iv(program, gl::VALIDATE_STATUS);
    val == gl::TRUE as i32
}

/// # Returns program info log length
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_program_info_log_length(Program(42)), 7);
/// ```
///
/// # Description
/// Returns the number of characters in the information log for `program` including the null
/// termination character (i.e., the size of the character buffer required to store the information
/// log). If `program` has no information log, a value of 0 is returned.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_info_log_length] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_info_log_length(program: Program) -> u32 {
    let val = get_program_iv(program, gl::INFO_LOG_LENGTH);
    val as u32
}

/// # Returns program number of attached shaders
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_program_attached_shaders(Program(42)), 7);
/// ```
///
/// # Description
/// Returns the number of shader objects attached to program.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_attached_shaders] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_attached_shaders(program: Program) -> u32 {
    let val = get_program_iv(program, gl::ATTACHED_SHADERS);
    val as u32
}

/// # Returns program number of active attributes
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_program_active_attributes(Program(42)), 7);
/// ```
///
/// # Description
/// Returns the number of active attribute variables for program.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_active_attributes] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_active_attributes(program: Program) -> u32 {
    let val = get_program_iv(program, gl::ACTIVE_ATTRIBUTES);
    val as u32
}

/// # Returns program maximum numbfer of attributes
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_program_attribute_max_length(Program(42)), 7);
/// ```
///
/// # Description
/// Returns the length of the longest active attribute name for `program`, including the null
/// termination character (i.e., the size of the character buffer required to store the longest
/// attribute name). If no active attributes exist, 0 is returned.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_attribute_max_length] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_attribute_max_length(program: Program) -> u32 {
    let val = get_program_iv(program, gl::ACTIVE_ATTRIBUTE_MAX_LENGTH);
    val as u32
}

/// # Returns program number of active uniforms
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_program_active_uniforms(Program(42)), 7);
/// ```
///
/// # Description
/// Returns the number of active uniform variables for `program`.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_active_attrib]
/// * [get_active_uniform]
/// * [get_attached_shaders]
/// * [get_program_info_log]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_active_uniforms] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [create_program]
/// * [delete_program]
/// * [get_shader]
/// * [link_program]
/// * [validate_program]
pub fn get_program_active_uniforms(program: Program) -> u32 {
    let val = get_program_iv(program, gl::ACTIVE_UNIFORMS);
    val as u32
}

/// # Returns the information log for a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetProgramInfoLog.xhtml>
///
/// # Arguments
/// * `program` - Specifies the program object whose information log is to be queried.
/// * `buffer` - Specifies a mut slice of characters that is used to return the information log.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// let mut buffer = [0; 1024];
/// let contents: &[u8] = get_program_info_log(Program(42), &mut buffer);
/// let info_log = std::str::from_utf8(contents).unwrap();
/// dbg!(info_log);
/// ```
///
/// # Description
/// [get_program_info_log] returns the information log for the specified `program` object. The
/// information log for a program object is modified when the program object is linked or validated.
/// The string that fills `buffer` will be null terminated. However the returned sub-slice will have
/// the null terminator stripped.
///
/// [get_program_info_log] returns as much of the information log as it can, up to a maximum of
/// available in the given `buffer`. The size of the buffer required to store the returned
/// information log can be obtained by calling [get_program_info_log_length].
///
/// The information log for a program object is either an empty string, or a string containing
/// information about the last link operation, or a string containing information about the last
/// validation operation. It may contain diagnostic messages, warning messages, and other
/// information. When a program object is created, its information log will be a string of length 0.
///
/// The information log for a program object is the OpenGL implementer's primary mechanism for
/// conveying information about linking and validating. Therefore, the information log can be
/// helpful to application developers during the development process, even when these operations are
/// successful. Application developers should not expect different OpenGL implementations to produce
/// identical information logs.
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` does not refer to a program object.
///
/// # Associated Gets
/// * [get_program_info_log_length]
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_program_info_log] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [get_shader_info_log]
/// * [link_program]
/// * [validate_program]
pub fn get_program_info_log(program: Program, buffer: &mut [u8]) -> &[u8] {
    let program = program.0;
    let max_length = buffer.len() as GLsizei;
    let mut length = Default::default();
    let length_out = &mut length as *mut GLsizei;
    let info_log_out = buffer.as_mut_ptr() as *mut GLchar;

    // SAFE: synchronous write to `buffer`, no memory retained
    unsafe { gl::GetProgramInfoLog(program, max_length, length_out, info_log_out) };

    // "The number of characters actually returned, excluding the null termination character, is
    // specified by length", so the null terminator will *not* be included in the returned sub-slice
    let length = length as usize;
    &buffer[..length]
}

fn get_shader_iv(shader: Shader, pname: GLenum) -> i32 {
    let shader = shader.0;
    let mut params = GLint::default();
    let params_out = &mut params as *mut GLint;

    // SAFE: synchronous write to `params_out`, no memory retained
    unsafe { gl::GetShaderiv(shader, pname, params_out) };
    params
}

/// # Return the shader type
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_shader_type(Shader(42)), Ok(ShaderType::Vertex));
/// ```
///
/// # Description
/// Return the shader type of `shader` that was given for [create_shader]. If OpenGL has an internal
/// failure, and data conversion fails, the original value is
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` does not refer to a shader object.
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_shader_type] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
/// * [get_program]
/// * [shader_source]
pub fn get_shader_type(shader: Shader) -> Result<ShaderType, i32> {
    let val = get_shader_iv(shader, gl::SHADER_TYPE);
    match val as GLenum {
        gl::VERTEX_SHADER => Ok(ShaderType::Vertex),
        gl::FRAGMENT_SHADER => Ok(ShaderType::Fragment),
        gl::GEOMETRY_SHADER => Ok(ShaderType::Geometry),
        gl::COMPUTE_SHADER => Ok(ShaderType::Compute),
        gl::TESS_CONTROL_SHADER => Ok(ShaderType::TessControl),
        gl::TESS_EVALUATION_SHADER => Ok(ShaderType::TessEvaluation),
        _ => Err(val),
    }
}

/// # Return the shader delete status
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(get_shader_delete_status(Shader(42)));
/// ```
///
/// # Description
/// Returns true if `shader` is currently flagged for deletion, and false otherwise.
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` does not refer to a shader object.
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_shader_delete_status] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
/// * [get_program]
/// * [shader_source]
pub fn get_shader_delete_status(shader: Shader) -> bool {
    let val = get_shader_iv(shader, gl::DELETE_STATUS);
    val == gl::TRUE as i32
}

/// # Return the shader compile status
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(get_shader_compile_status(Shader(42)));
/// ```
///
/// # Description
/// Returns true if the last compile operation on `shader` was successful, and false otherwise.
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` does not refer to a shader object.
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_shader_compile_status] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
/// * [get_program]
/// * [shader_source]
pub fn get_shader_compile_status(shader: Shader) -> bool {
    let val = get_shader_iv(shader, gl::COMPILE_STATUS);
    val == gl::TRUE as i32
}

/// # Return the shader info log length
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object to be queried.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert_eq!(get_shader_info_log_length(Shader(42)), 7);
/// ```
///
/// # Description
/// Returns the number of characters in the information log for `shader` including the null
/// termination character (i.e., the size of the character buffer required to store the information
/// log). If `shader` has no information log, a value of 0 is returned.
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` does not refer to a shader object.
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_shader_info_log_length] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
/// * [get_program]
/// * [shader_source]
pub fn get_shader_info_log_length(shader: Shader) -> u32 {
    let val = get_shader_iv(shader, gl::INFO_LOG_LENGTH);
    val as u32
}

/// # Returns the information log for a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetShaderInfoLog.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the shader object whose information log is to be queried.
/// * `buffer` - Specifies a mut slice of characters that is used to return the information log.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// ```
///
/// # Description
/// [get_shader_info_log] returns the information log for the specified shader object. The
/// information log for a shader object is modified when the shader is compiled. The string that is
/// returned will be null terminated.
///
/// [get_shader_info_log] returns in `buffer` as much of the information log as it can. The number
/// of characters actually returned, excluding the null termination character, is returned in the
/// sub-slice. The size of the buffer required to store the returned information log can be obtained
/// by calling [get_shader_info_log_length].
///
/// The information log for a shader object is a string that may contain diagnostic messages,
/// warning messages, and other information about the last compile operation. When a shader object
/// is created, its information log will be a string of length 0.
///
/// The information log for a shader object is the OpenGL implementer's primary mechanism for
/// conveying information about the compilation process. Therefore, the information log can be
/// helpful to application developers during the development process, even when compilation is
/// successful. Application developers should not expect different OpenGL implementations to produce
/// identical information logs.
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` does not refer to a shader object.
///
/// # Associated Gets
/// * [get_shader_info_log_length]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [get_shader_info_log] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [get_program_info_log]
/// * [link_program]
/// * [validate_program]
pub fn get_shader_info_log(shader: Shader, buffer: &mut [u8]) -> &[u8] {
    let shader = shader.0;
    let max_length = buffer.len() as GLsizei;
    let mut length = GLsizei::default();
    let length_out = &mut length as *mut GLsizei;
    let info_log_out = buffer.as_mut_ptr() as *mut GLchar;

    // SAFE: synchronous write to out params, no memory retained
    unsafe { gl::GetShaderInfoLog(shader, max_length, length_out, info_log_out) };

    // "The number of characters actually returned, excluding the null termination character, is
    // specified by length", so the null terminator will *not* be included in the returned sub-slice
    let length = length as usize;
    &buffer[..length]
}

/// # Determines if a name corresponds to a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies a potential program object.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(is_program(Program(42)));
/// ```
///
/// # Description
/// [is_program] returns true if `program` is the name of a program object previously created with
/// [create_program] and not yet deleted with [delete_program]. If `program` is zero or a non-zero
/// value that is not the name of a program object, or if an error occurs, [is_program] returns
/// false.
///
/// No error is generated if `program` is not a valid program object name.
///
/// A program object marked for deletion with [delete_program] but still in use as part of current
/// rendering state is still considered a program object and [is_program] will return true.
///
/// # Associated Gets
/// * [get_current_program]
/// * [get_active_attrib] with arguments `program` and the index of an active attribute variable
/// * [get_active_uniform] with arguments `program` and the index of an active uniform variable
/// * [get_attached_shaders] with arguments `program`
/// * [get_attrib_location] with arguments `program` and the name of an attribute variable
/// * all `get_program_*` variants
/// * [get_program_info_log] with arguments `program`
/// * [get_uniform] with arguments `program` and the location of a uniform variable
/// * [get_uniform_location] with arguments `program` and the name of a uniform variable
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [is_program] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [bind_attrib_location]
/// * [create_program]
/// * [delete_program]
/// * [detach_shader]
/// * [link_program]
/// * all `uniform_*` variants
/// * [use_program]
/// * [validate_program]
pub fn is_program(program: Program) -> bool {
    let program = program.0;
    let val = unsafe { gl::IsProgram(program) };
    val == gl::TRUE
}

/// # Determines if a name corresponds to a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glIsShader.xhtml>
///
/// # Arguments
/// * `shader` - Specifies a potential shader object.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// assert!(is_shader(Shader(42)));
/// ```
///
/// # Description
/// [is_shader] returns true if `shader` is the name of a shader object previously created with
/// [create_shader] and not yet deleted with [delete_shader]. If `shader` is zero or a non-zero
/// value that is not the name of a shader object, or if an error occurs, [is_shader] returns false.
///
/// No error is generated if `shader` is not a valid shader object name.
///
/// A shader object marked for deletion with [delete_shader] but still attached to a program object
/// is still considered a shader object and [is_shader] will return true.
///
/// # Associated Gets
/// * [get_attached_shaders] with a valid program object
/// * all `get_shader_*` variants
/// * [get_shader_info_log]
/// * [get_shader_source]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [is_shader] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
pub fn is_shader(shader: Shader) -> bool {
    let shader = shader.0;
    let val = unsafe { gl::IsShader(shader) };
    val == gl::TRUE
}

/// # Links a program object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glLinkProgram.xhtml>
///
/// # Arguments
/// * `program` - Specifies the handle of the program object to be linked.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// link_program(Program(42));
/// ```
///
/// # Description
/// [link_program] links the program object specified by program.
///
/// The status of the link operation will be stored as part of the program object's state. This
/// value will be set to true if the program object was linked without errors and is ready for use,
/// and false otherwise. It can be queried by calling [get_program_link_status].
///
/// As a result of a successful link operation, all active user-defined uniform variables belonging
/// to program will be initialized to 0, and each of the program object's active uniform variables
/// will be assigned a location that can be queried by calling [get_uniform_location]. Also, any
/// active user-defined attribute variables that have not been bound to a generic vertex attribute
/// index will be bound to one at this time.
///
/// Linking of a program object can fail for a number of reasons as specified in the OpenGL Shading
/// Language Specification. The following lists some of the conditions that will cause a link error:
/// * The number of active attribute variables supported by the implementation has been exceeded.
/// * The storage limit for uniform variables has been exceeded.
/// * The number of active uniform variables supported by the implementation has been exceeded.
/// * The main function is missing for the vertex, geometry or fragment shader.
/// * A varying variable actually used in the fragment shader is not declared in the same way (or is
/// not declared at all) in the vertex shader, or geometry shader if present.
/// * A reference to a function or variable name is unresolved.
/// * A shared global is declared with two different types or two different initial values.
/// * One or more of the attached shader objects has not been successfully compiled.
/// * Binding a generic attribute matrix caused some rows of the matrix to fall outside the allowed
/// maximum of [get_max_vertex_attribs].
/// * Not enough contiguous vertex attribute slots could be found to bind attribute matrices.
/// * The program object contains objects to form a fragment shader but does not contain objects to
/// form a vertex shader.
/// * The program object contains objects to form a geometry shader but does not contain objects to
/// form a vertex shader.
/// * The program object contains objects to form a geometry shader and the input primitive type,
/// output primitive type, or maximum output vertex count is not specified in any compiled geometry
/// shader object.
/// * The program object contains objects to form a geometry shader and the input primitive type,
/// output primitive type, or maximum output vertex count is specified differently in multiple
/// geometry shader objects.
/// * The number of active outputs in the fragment shader is greater than the value of
/// [get_max_draw_buffers].
/// * The program has an active output assigned to a location greater than or equal to the value of
/// [get_max_dual_source_draw_buffes] and has an active output assigned an index greater than or
/// equal to one.
/// * More than one varying out variable is bound to the same number and index.
/// * The explicit binding assigments do not leave enough space for the linker to automatically
/// assign a location for a varying out array, which requires multiple contiguous locations.
/// * The count specified by [transform_feedback_varyings] is non-zero, but the program object has
/// no vertex or geometry shader.
/// * Any variable name specified to [transform_feedback_varyings] in the varyings array is not
/// declared as an output in the vertex shader (or the geometry shader, if active).
/// * Any two entries in the varyings array given [transform_feedback_varyings] specify the same
/// varying variable.
/// * The total number of components to capture in any transform feedback varying variable is
/// greater than [get_max_transform_feedback_separate_components] and the buffer mode is
/// [BufferMode::SeparateAttribs].
///
/// When a program object has been successfully linked, the program object can be made part of
/// current state by calling [use_program]. Whether or not the link operation was successful, the
/// program object's information log will be overwritten. The information log can be retrieved by
/// calling [get_program_info_log].
///
/// [link_program] will also install the generated executables as part of the current rendering
/// state if the link operation was successful and the specified program object is already currently
/// in use as a result of a previous call to [use_program]. If the program object currently in use
/// is relinked unsuccessfully, [get_program_link_status] will be false, but the executables and
/// associated state will remain part of the current state until a subsequent call to [use_program]
/// removes it from use. After it is removed from use, it cannot be made part of current state until
/// it has been successfully relinked.
///
/// If `program` contains shader objects of type [ShaderType::Vertex], and optionally of type
/// [ShaderType::Geometry], but does not contain shader objects of type [ShaderType::Fragment], the
/// vertex shader executable will be installed on the programmable vertex processor, the geometry
/// shader executable, if present, will be installed on the programmable geometry processor, but no
/// executable will be installed on the fragment processor. The results of rasterizing primitives
/// with such a program will be undefined.
///
/// The program object's information log is updated and the program is generated at the time of the
/// link operation. After the link operation, applications are free to modify attached shader
/// objects, compile attached shader objects, detach shader objects, delete shader objects, and
/// attach additional shader objects. None of these operations affects the information log or the
/// program that is part of the program object.
///
/// If the link operation is unsuccessful, any information about a previous link operation on
/// program is lost (i.e., a failed link does not restore the old state of program ). Certain
/// information can still be retrieved from program even after an unsuccessful link operation. See
/// for instance [get_active_attrib] and [get_active_uniform].
///
/// # Errors
/// * [Error::InvalidValue] - if `program` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `program` is not a program object.
/// * [Error::InvalidOperation] - if `program` is the currently active program object and transform
/// feedback mode is active.
///
/// # Associated Gets
/// * [get_current_program]
/// * [get_active_attrib] with arguments `program` and the index of an active attribute variable
/// * [get_active_uniform] with arguments `program` and the index of an active uniform variable
/// * [get_attached_shaders] with arguments `program`
/// * [get_attrib_location] with arguments `program` and the name of an attribute variable
/// * all `get_program_*` variants
/// * [get_program_info_log] with arguments `program`
/// * [get_uniform] with arguments `program` and the location of a uniform variable
/// * [get_uniform_location] with arguments `program` and the name of a uniform variable
/// * [is_program]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [link_program] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [attach_shader]
/// * [bind_attrib_location]
/// * [compile_shader]
/// * [create_program]
/// * [delete_program]
/// * [detach_shader]
/// * all `uniform_*` variants
/// * [use_program]
/// * [validate_program]
pub fn link_program(program: Program) {
    let program = program.0;

    // SAFE: synchronous integer copy
    unsafe { gl::LinkProgram(program) }
}

/// # Replaces the source code in a shader object
/// <https://registry.khronos.org/OpenGL-Refpages/gl4/html/glShaderSource.xhtml>
///
/// # Arguments
/// * `shader` - Specifies the handle of the shader object whose source code is to be replaced.
/// * `source` - Specifies the source code to be loaded into the shader.
///
/// # Example
/// ```no_run
/// # use rgl::prelude::*;
/// shader_source(Shader(42), r#"
/// #version 330 core
///
/// out vec4 fragment_colour;
///
/// void main() {
///     fragment_colour = vec4(1.0, 0.0, 0.0, 1.0);     
/// }
/// "#);
/// ```
///
/// # Description
/// [shader_source] sets the source code in shader to the source code specified by `source`. Any
/// source code previously stored in the shader object is completely replaced. The source code
/// string is not scanned or parsed at this time; they are simply copied into the specified shader
/// object.
///
/// OpenGL copies the shader source code strings when [shader_source] is called, so an application
/// may free its copy of the source code strings immediately after the function returns.
///
/// # Errors
/// * [Error::InvalidValue] - if `shader` is not a value generated by OpenGL.
/// * [Error::InvalidOperation] - if `shader` is not a shader object.
///
/// # Associated Gets
/// * [get_shader_source_length]
/// * [get_shader_source]
/// * [is_shader]
///
/// # Version Support
///
/// | Function / Feature Name | 2.0 | 2.1 | 3.0 | 3.1 | 3.2 | 3.3 | 4.0 | 4.1 | 4.2 | 4.3 | 4.4 | 4.5 |
/// |-------------------------|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
/// | [shader_source] | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y | Y |
///
/// # See Also
/// * [compile_shader]
/// * [create_shader]
/// * [delete_shader]
pub fn shader_source(shader: Shader, source: &str) {
    let shader = shader.0;
    let count = 1;
    let strings = [source.as_ptr()];
    let string = strings.as_ptr() as *const *const GLchar;
    let string_length = source.len() as GLint;
    let length = &string_length as *const GLint;

    // SAFE: synchronous memory read of `string` and `length`, no pointers
    unsafe { gl::ShaderSource(shader, count, string, length) };
}
